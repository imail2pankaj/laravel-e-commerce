<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\BaseCrudController;
use App\Http\Controllers\Controller;
use App\Interfaces\ProductRepositoryInterface;
use App\Models\Brand;
use App\Models\Category;
use App\Models\Product;
use App\Models\ProductImage;
use App\Services\Datatable\ActionBuilder;
use App\Services\ImageService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use Yajra\DataTables\Facades\DataTables;

class ProductController extends BaseCrudController
{
    protected string $moduleKey = 'products';   
    protected $productRepo;
    protected $imageService;
   public function __construct(ProductRepositoryInterface $productRepo,  ImageService $imageService)
   {
      parent::__construct(); 
      $this->productRepo=$productRepo;
      $this->imageService = $imageService;
   }

   public function index()
   {
      return view('admin.product.product-list');
   }


    public function getTableData()
   {
      $product = $this->productRepo->allQuery();

     
        if ($status= request('status')) {
            $product->where('status', $status);
        }


      return DataTables::eloquent($product)
         ->addIndexColumn()
        ->addColumn('status', function ($product) {
            if ($product->status === 'published') {
               $badgeClass = 'bg-success';
            } else {
               $badgeClass = 'bg-secondary'; // draft
            }

            return '<span class="badge ' . $badgeClass . '">'
                  . ucfirst($product->status) .
                  '</span>';
         })

         ->addColumn('action', function ($val) {
               return ActionBuilder::make($val, [
                  'edit' => [
                     'can' => auth()->user()->hasPermissionTo($this->moduleKey . '.edit'),
                     'url' => route('product.edit', $val->id)
                  ],
                  'delete' => [
                     'can' => auth()->user()->hasPermissionTo($this->moduleKey . '.delete'),
                     'url' => route('product.delete', $val->id)
                  ]
               ]);
         })
         ->rawColumns([ 'status','action'])
         ->make(true);
   }

   public function create()
   {
      $brands=Brand::all();
      $categories=Category::all();
      return view('admin.product.product-form', compact('brands','categories'));
   }

    public function createTest()
    {
        $brands=Brand::all();
        $categories=Category::all();
        return view('admin.product.product-test-form', compact('brands','categories'));
    }

    public function store(Request $request)
    {
        // dd($request->all());
        // VALIDATION
        $validated = $request->validate([
            'name'              => 'required|string|max:255',
            'slug'              => 'required|string|max:255|unique:products,slug',
            'brand'             => 'required|exists:brands,id',
            'category'          => 'required|exists:categories,id',
            'short_description' => 'nullable|string',
            'description'       => 'nullable|string', // your editor HTML content
            'main_image'        => 'nullable|image|max:4096', // 4MB max
            'status'            => 'required|string|in:published,draft',
            'is_active'         => 'boolean',
            'meta_title'        => 'nullable|string|max:255',
            'meta_description'  => 'nullable|string|max:500',
            'meta_keywords'     => 'nullable|string', // Tagify returns comma-separated or JSON
        ]);


        // HANDLE MAIN IMAGE
        if ($request->hasFile('main_image')) {
            $filename = uniqid() . '-' . time() . '.' . $request->file('main_image')->extension();
            $path = $request->file('main_image')->storeAs('product/main_image', $filename, 'public');
            $validated['main_image'] = $path;
        }

        // FIX FIELDS FOR DATABASE (match your model)
        $validated['brand_id']     = $validated['brand'];     // convert brand → brand_id
        $validated['category_id']  = $validated['category'];  // convert category → category_id
        $validated['is_active']    = $request->is_active ?? 0;

        unset($validated['brand']);
        unset($validated['category']);

        // META KEYWORDS (Tagify)
        // If Tagify returns JSON → convert to CSV
        if ($request->meta_keywords) {
            $validated['meta_keywords'] = $request->meta_keywords;
        }

        // SAVE PRODUCT
        $product = Product::create($validated);

        // REDIRECT TO EDIT PAGE (for image management)
        return redirect()
            ->route('product.edit', $product->id )
            ->with('success', 'Product created successfully! Now you can manage gallery images.');
    }


    public function edit($id)
    {
        $product = Product::with('images')->findOrFail($id);

        $brands = Brand::all();
        $categories = Category::all();

        // If meta_keywords is JSON, decode for Tagify
        $metaKeywords = $product->meta_keywords;

        return view('admin.product.product-test-form', compact(
            'product',
            'brands',
            'categories',
            'metaKeywords'
        ));
    }

    public function update(Request $request, $id)
    {
        $product = Product::findOrFail($id);

        // VALIDATION
        $validated = $request->validate([
            'name'              => 'required|string|max:255',
            'slug'              => 'required|string|max:255|unique:products,slug,' . $product->id,
            'brand'             => 'required|exists:brands,id',
            'category'          => 'required|exists:categories,id',
            'short_description' => 'nullable|string',
            'description'       => 'nullable|string', // HTML from editor
            'main_image'        => 'nullable|image|max:4096',
            'status'            => 'required|string|in:published,draft',
            'is_active'         => 'boolean',
            'meta_title'        => 'nullable|string|max:255',
            'meta_description'  => 'nullable|string|max:500',
            'meta_keywords'     => 'nullable|string', // Tagify JSON or CSV
        ]);

        // HANDLE MAIN IMAGE (REPLACE)
        if ($request->hasFile('main_image')) {

            // delete old image if exists
            if ($product->main_image && \Storage::disk('public')->exists($product->main_image)) {
                \Storage::disk('public')->delete($product->main_image);
            }

            $filename = uniqid() . '-' . time() . '.' . $request->file('main_image')->extension();
            $path = $request->file('main_image')->storeAs('product/main_image', $filename, 'public');

            $validated['main_image'] = $path;
        }

        // MAP brand → brand_id & category → category_id
        $validated['brand_id'] = $validated['brand'];
        $validated['category_id'] = $validated['category'];

        unset($validated['brand']);
        unset($validated['category']);

        // IS ACTIVE
        $validated['is_active'] = $request->is_active ?? 0;

        // META KEYWORDS (raw Tagify data)
        $validated['meta_keywords'] = $request->meta_keywords;

        // UPDATE PRODUCT
        $product->update($validated);

        return redirect()
            ->route('product.edit', $product->id)
            ->with('success', 'Product updated successfully!');
    }

    public function upload(Request $request)
    {
        $request->validate([
            'product_id' => 'required|exists:products,id',
            'images.*'   => 'required|image|max:4096',
        ]);

        if (!$request->hasFile('images')) {
            return back()->with('error', 'Please select at least one image.');
        }

        foreach ($request->file('images') as $file) {

            $filename = uniqid() . '-' . time() . '.' . $file->extension();
            $path = $file->storeAs('product/images', $filename, 'public');

            ProductImage::create([
                'product_id' => $request->product_id,
                'image_path' => 'product/images/' . $filename,
                'sort_order' => 0,
            ]);
        }

        return back()->with('success', 'Images uploaded successfully!');
    }

    public function deleteImage($id)
    {
        $image = ProductImage::findOrFail($id);

        if (\Storage::disk('public')->exists($image->image_path)) {
            \Storage::disk('public')->delete($image->image_path);
        }

        $image->delete();

        return response()->json(['success' => true]);
    }

    public function sortImages(Request $request)
    {
        foreach ($request->order as $item) {
            ProductImage::where('id', $item['id'])
                ->update(['sort_order' => $item['position']]);
        }

        return response()->json(['success' => true]);
    }


    public function destroy($id)
    {
      $category = $this->productRepo->find($id);

       $this->productRepo->delete($id);
      return redirect()->route('product.list')->with('success','Record Delete Successfully...!!');

    }

}
